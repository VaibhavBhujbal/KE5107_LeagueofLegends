---
title: "Process the league of legends dataset"
output: html_notebook
---

## Global configuration variables to control the data in the generated file
```{r}
 shouldDiscardTimeSeriesColumnsFromProcessedFile <- FALSE
 processedFileNameWithExtension <- "processed_matches.csv"
```

## Process the current data and get:

1. Number of game elements (towers, inhibitors, dragons and barons) killed or destroyed by red and blue teams in the columns bTowersNum	bInhibsNum	bDragonsNum	bBaronsNum	bHeraldsNum	rTowersNum	rInhibsNum	rDragonsNum	rBaronsNum	rHeraldsNum

2. The time when the game element (towers, inhibitors, dragons and barons) was destroyed by the red and the blue teams. This value is 1000 if there was no element destroyed by that team. The columns created are bTowersFirstDestroyedTime,	rTowersFirstDestroyedTime,		bInhibsFirstDestroyedTime,	rInhibsFirstDestroyedTime,		bDragonsFirstDestroyedTime,	rDragonsFirstDestroyedTime

3. The team that first killed pr destroyed a game element (towers, inhibitors, dragons and barons). This value is 1 if it was performed by the Blue team and 0 if performed by the Red team. These columns are TowersFirstKillBy,	InhibsFirstKillBy, DragonsFirstKillBy
```{r}
library(stringr)

setwd("H:\\KE 5107 Projects\\code\\KE5107_LeagueofLegends")
matchesData = read.csv("data/matches.csv")
gameElements <- c("Towers", "Inhibs", "Dragons", "Barons") 

# Prepends r to the item
prependRed <- function(p) {
  paste("r", p, sep="")
}

# Prepends b to the item
prependBlue <- function(p) {
  paste("b", p, sep="")
}

# Get the smallest number from a series of numbers
getSmallestNumber <- function(value) {
  if (value != "[]") {
    # Get all the number strings from the list
    allNumbers <- str_extract_all(value, "[0-9]*[.][0-9]*")
    
    # Get the number strings in a list
    allNumbersList <- unlist(allNumbers)
    
    # Convert each item to a number
    allNumbersList <- as.numeric(allNumbersList)
    
    # Sort all the numbers
    allNumbersListSorted <- allNumbersList[order(allNumbersList)]
    
    # Get the first number
    return(allNumbersListSorted[1])
  }
  
  # A high value if the no number is not present
  return(10000)
}

# Get the Kills columns for blue and red teams
blueKillsColumns <- lapply(gameElements, prependBlue)
redKillsColumns <- lapply(gameElements, prependRed)

# Combine the Kills columns
allKillsColumns <- c(blueKillsColumns, redKillsColumns)

for (i in 1:length(allKillsColumns)) {
  columnName <- unlist(allKillsColumns[i])
  outputColumnName <- paste(columnName, "Num", sep="")
  
  # Each item is enclosed in its own square brackets. Note that there is an extra [ to contain all the elements which needs to be removed
  matchesData[,outputColumnName] <- str_count(matchesData[,columnName], "\\[")-1
}

firstKillElements <- c("Towers", "Inhibs", "Dragons", "Barons") 
for (i in 1: length(firstKillElements)) {
  columnName <- unlist(firstKillElements[i])
  
  # Get the red and blue specific column names
  redColumnName <- paste("r", columnName,sep="")
  blueColumnName <- paste("b", columnName,sep="")
  
  # Get the output column name to store the first destroyed time
  redOutputColumnName <- paste("r", columnName, "FirstDestroyedTime",sep="")
  blueOutputColumnName <- paste("b", columnName, "FirstDestroyedTime",sep="")
  
  # Get the first number from the list of numbers
  
  matchesData[,blueOutputColumnName] <- unlist(lapply(as.character(matchesData[,blueColumnName]), getSmallestNumber))
  
  matchesData[,redOutputColumnName] <- unlist(lapply(as.character(matchesData[,redColumnName]), getSmallestNumber))
  
  # convert the first kill times to numeric for comparison
  matchesData[,blueOutputColumnName] <- as.numeric(matchesData[,blueOutputColumnName])
  matchesData[,redOutputColumnName] <- as.numeric(matchesData[,redOutputColumnName])
  
  # Get the name of the output column
  firstKillByColumnName <- paste(columnName, "FirstKillBy",sep="")
  
  matchesData[,firstKillByColumnName] <- as.numeric(matchesData[,blueOutputColumnName] < matchesData[,redOutputColumnName])
}

```

## Code to get effectiveness of teams (Wins / Total Matches Played by Team)
## - rWinEfficiency : how efficient red is at winning matches
## - bWinEfficiency : how efficient blue is at winning matches
```{r}
# Charles's snippet to get YearSeason variable for easier seasonal handling
matchesData$YearSeason <- ifelse(matchesData$Season == "Spring", paste("01/01/", as.character(matchesData$Year), sep=""), paste("01/06/", as.character(matchesData$Year), sep=""))

library(data.table)

# Total matches played by each team (consider them as blue or red)
blueTeams = data.frame(table(matchesData$blueTeamTag))
redTeams = data.frame(table(matchesData$redTeamTag))
names(blueTeams)[names(blueTeams) == 'Var1'] <- 'Team'
names(redTeams)[names(redTeams) == 'Var1'] <- 'Team'
combinedPlayed <- merge(blueTeams, redTeams, by="Team", all=TRUE)
setnames(combinedPlayed, "Freq.y", "rMatchesPlayed")
setnames(combinedPlayed, "Freq.x", "bMatchesPlayed")
combinedPlayed$totalPlayed <- combinedPlayed$bMatchesPlayed + combinedPlayed$rMatchesPlayed

# Get each team wins, whether they won as blue or red
bluewin <- subset(matchesData, matchesData$bResult==1)
redwin <- subset(matchesData, matchesData$bResult==0)
blueTeamWin = data.frame(table(bluewin$blueTeamTag))
redTeamWin = data.frame(table(redwin$redTeamTag))
names(blueTeamWin)[names(blueTeamWin) == 'Var1'] <- 'Team'
names(redTeamWin)[names(redTeamWin) == 'Var1'] <- 'Team'
combinedWins <- merge(blueTeamWin, redTeamWin, by="Team", all=TRUE)
setnames(combinedWins, "Freq.y", "rMatchesWon")
setnames(combinedWins, "Freq.x", "bMatchesWon")
combinedWins$totalWon <- combinedWins$bMatchesWon + combinedWins$rMatchesWon

# Merge and calc the win efficiency of each team
combinedTeams <- merge(combinedWins, combinedPlayed, by="Team")
combinedTeams$winEfficiency = combinedTeams$totalWon / combinedTeams$totalPlayed
combinedTeams[is.na(combinedTeams)] <- 0 

# Helper fn to shift columns specified - this is heavy on processing, is there a better way? 
movetolast <- function(data, move) {
  data[c(setdiff(names(data), move), move)]
}

combinedTeams_blue = combinedTeams[,-c(2:7)] # remove unecessary columns
setnames(combinedTeams_blue, "winEfficiency", "bWinEfficiency")
setnames(combinedTeams_blue, "Team", "blueTeamTag")
matchesData <- merge(combinedTeams_blue, matchesData, by="blueTeamTag")

combinedTeams_red = combinedTeams[,-c(2:7)] # remove unecessary columns
setnames(combinedTeams_red, "winEfficiency", "rWinEfficiency")
setnames(combinedTeams_red, "Team", "redTeamTag")
matchesData <- merge(combinedTeams_red, matchesData, by="redTeamTag")

matchesData <- (matchesData[with(matchesData, order(matchesData$League)), ])
#head(matchesData)
movetolast(matchesData, c("bWinEfficiency", "rWinEfficiency"))

```

## Code to get preferred winning player and champions lineup, with respect to player positions. 
##- isBluePreferredLineup : is the current config of players blue's preferred winning formation (for the season)?
##- isRedPreferredLineup : same, but for red
##- isBluePreferredChamp : is the current config of champions blue's preferred winning champions formation (for the season)?
##- isRedPreferredChamp: same, but for red

```{r}
library(plyr)
# Warning : this code takes some time to load as there's a nested for loop

# add new columns to matches, default val 0
matchesData$isBluePreferredLineup <- 0
matchesData$isRedPreferredLineup <- 0
matchesData$isBluePreferredChamps <- 0
matchesData$isRedPreferredChamps <- 0

# this gets the top frequency data from each col a-e for dataframe data
# returns a list of the desired top, adc, jungle, support, middle pos values
getTopData <- function(data, a, b, c, d, e) {
  top <- names (sort(table(data[[a]]), decreasing=TRUE)[1] )
  adc <- names (sort(table(data[[b]]), decreasing=TRUE)[1] )
  jungle <- names (sort(table(data[[c]]), decreasing=TRUE)[1])
  support <- names (sort(table(data[[d]]), decreasing=TRUE)[1])
  middle <- names (sort(table(data[[e]]), decreasing=TRUE)[1])
  
  return(list(top, adc, jungle, support, middle)) 
}

seasons = data.frame(table(matchesData$YearSeason))
names(seasons)[names(seasons) == 'Var1'] <- 'YearSeasons'

for (season_num in 1:nrow(seasons)) {
  Season <- seasons[season_num,1] # 7 in total

  for (row  in 1:nrow(combinedPlayed)) { 
    Team <- combinedPlayed[row, 1]
    if (is.na(Team)) next # skip nonsense no team name data
    
    # Get all instances of when this team wins for this season (blue/red)
    blueWins <- matchesData[which(matchesData$blueTeamTag==Team & matchesData$bResult==1 & matchesData$YearSeason==Season),]
    redWins <- matchesData[which(matchesData$redTeamTag==Team & matchesData$bResult==0 & matchesData$YearSeason==Season),]
    
    # In all the blueWins for this team, get the most popular player for each pos for THIS SEASON
    blue_poplist <- getTopData(blueWins, "blueTop", "blueADC", "blueJungle", "blueSupport", "blueMiddle")
    
    # In all the redWins for this team, get the most popular player for each pos for THIS SEASON
    red_poplist <- getTopData(redWins, "redTop", "redADC", "redJungle", "redSupport", "redMiddle")
    
    # Mark all those matches in main df that fit this particular combi for this team as having the preferred line-up
    matchesData$isBluePreferredLineup <- ifelse((matchesData$blueTop==blue_poplist[1] & 
                                             matchesData$blueADC==blue_poplist[2] & 
                                             matchesData$blueJungle==blue_poplist[3] & 
                                             matchesData$blueSupport==blue_poplist[4] & 
                                             matchesData$blueMiddle==blue_poplist[5] & 
                                             matchesData$YearSeason==Season), 1, 
                                             matchesData$isBluePreferredLineup)
    
    matchesData$isRedPreferredLineup <- ifelse((matchesData$redTop==red_poplist[1] & 
                                            matchesData$redADC==red_poplist[2] & 
                                            matchesData$redJungle==red_poplist[3] & 
                                            matchesData$redSupport==red_poplist[4] & 
                                            matchesData$redMiddle==red_poplist[5]  & 
                                            matchesData$YearSeason==Season), 1, 
                                            matchesData$isRedPreferredLineup)
    
    # In all the blueWins for this team, get the most popular champion for each pos for THIS SEASON
    blue_champlist <- getTopData(blueWins, "blueTopChamp", "blueADCChamp", "blueJungleChamp", "blueSupportChamp", "blueMiddleChamp")
    
    # In all the redWins for this team, get the most popular champion for each pos for THIS SEASON
    red_champlist <- getTopData(redWins, "redTopChamp", "redADCChamp", "redJungleChamp", "redSupportChamp", "redMiddleChamp")
    
    # Mark all those matches that fit this particular combi for this team as having the preferred champions line-up
    matchesData$isBluePreferredChamps <- ifelse((matchesData$blueTopChamp==blue_champlist[1] & 
                                             matchesData$blueADCChamp==blue_champlist[2] & 
                                             matchesData$blueJungleChamp==blue_champlist[3] & 
                                             matchesData$blueSupportChamp==blue_champlist[4] & 
                                             matchesData$blueMiddleChamp==blue_champlist[5]  & 
                                             matchesData$YearSeason==Season), 1, 
                                             matchesData$isBluePreferredChamps)
    
    matchesData$isRedPreferredChamps <- ifelse((matchesData$redTopChamp==red_champlist[1] & 
                                            matchesData$redADCChamp==red_champlist[2] & 
                                            matchesData$redJungleChamp==red_champlist[3] & 
                                            matchesData$redSupportChamp==red_champlist[4] & 
                                            matchesData$redMiddleChamp==red_champlist[5] & 
                                            matchesData$YearSeason==Season), 1, 
                                            matchesData$isRedPreferredChamps)
  }
}

```



## Code to remove existing columns from the processed file that will be used for creating models
```{r}
# remove the gold diff column as it has redundant information
matchesData$golddiff <- NULL

# remove the rResults column as it too has redundant information
matchesData$rResult <- NULL

if (shouldDiscardTimeSeriesColumnsFromProcessedFile) {
  timeSeriesColumnNames <- c("goldblue", "bKills", "bTowers", "bInhibs", "bDragons", "bBarons", "bHeralds", "goldred", "rKills", "rTowers", "rInhibs", "rDragons", "rBarons", "rHeralds", "goldblueTop", "goldblueJungle", "goldblueMiddle", "goldblueADC", "goldblueSupport", "goldredTop", "goldredJungle", "goldredMiddle", "goldredADC", "goldredSupport")
  
  for (i in 1:length(timeSeriesColumnNames)) {
    columnName <- unlist(timeSeriesColumnNames[i])
    matchesData[,columnName] <- NULL
  }
}

```


## Write the current contents of the matchesData dataframe into a CSV in the current folder
```{r}
write.csv(matchesData, processedFileNameWithExtension, row.names = FALSE)
```
